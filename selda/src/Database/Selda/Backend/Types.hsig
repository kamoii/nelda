{-# LANGUAGE AllowAmbiguousTypes #-}
signature Database.Selda.Backend.Types where

import Data.Text (Text)
import Data.Typeable (Typeable)
{-
LiteralType や ResultType はバックエンドが使っている値を直接使う。
Selda での sum型を挟まないことで表現力やパフォーマンスの低下を防げる。
-}

-- | SQL backend にリテラルを渡す際の型
data LiteralType

-- | SQL backend のクエリの結果絵られるデータの型
data ResultType

-- | 結果が NULL かどうかの判定。
-- instance SqlType (Maybe a) の実装で必要
isResultNull :: ResultType -> Bool

-- | Debug用途
inspectResult :: ResultType -> Text

-- | Representation of an SQL type.
-- 通常 TText, TInt, TDateTime のような形式
-- TRowID は SQL backend の型ではなく, selda の都合上導入されていた論理型なので不要
data SqlTypeRep

instance Show SqlTypeRep
instance Eq SqlTypeRep
instance Ord SqlTypeRep

-- | スキーム定義での型表現
-- e.g. TText     = "TEXT"
sqlTypeDef :: SqlTypeRep -> Text

-- | Any datatype representable in SQL.
-- 実際にサポートされている型のみ。
-- NULL や 抽象化された ID は SqlType 型クラス('なし)で考慮する。
--
-- TDOO: SqlType, SqlType' を分けているのが吉と出るか...
-- TODO: Typeable 制約は SqlType のために付けているだけで後から外せるかも
class Typeable a => SqlType' a where
    -- | Create a literal of this type.
    toLiteral :: a -> LiteralType
    -- | The SQL representation for this type.
    sqlTypeRep :: SqlTypeRep
    -- | Convert an SqlValue into this type.
    fromResult :: ResultType -> a
    -- | Pring for insperct purpose
    inspectPrint :: a -> Text
    -- | Default value when using 'def' at this type.
    -- TODO: DEPRECATE。DEFAULTカラムの insert 時に使っているがこれは本来ライブラリが決めるべき値ではない。
    defaultValue :: a

{-
微妙なところ。
例えば SQLite はカラム定義として Bool はないが, Int の 1/0 が true/false として扱われている。
selda は SQL構築する際に Col s Bool を使っており, SqlType Bool がないと Database.Selda モジュールのコンパイルが通らない。
厳密に言うと カラムが取れる型と SQL中の型は一致しない。
ただ厳密にやりすぎると ergnomics が下がるため取りあえず以下のものはどのバックエンドも最低限の要求とする。
-}
instance SqlType' Int
instance SqlType' Text
instance SqlType' Double
instance SqlType' Bool

-- | Any column type that can be used with the 'min_' and 'max_' functions.
-- | Int
class SqlType' a => SqlOrdable a
