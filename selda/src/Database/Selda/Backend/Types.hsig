{-# LANGUAGE AllowAmbiguousTypes #-}
signature Database.Selda.Backend.Types where

import Data.Text (Text)
import Data.Typeable (Typeable)

{-
SqlParam や SqlValue はバックエンドが使っている値を直接使う。
Selda での sum型を挟まないことで表現力やパフォーマンスの低下を防げる。
-}

-- | SQL backend にリテラルを渡す際の型
data SqlParam

-- | NULL literal
-- | Needs for implementation of Lit a -> Literal
nullSqlParam :: SqlParam

-- | SQL backend のクエリの結果絵られるデータの型
data SqlValue

-- | 結果が NULL かどうかの判定。
-- instance SqlType (Maybe a) の実装で必要
isSqlValueNull :: SqlValue -> Bool

-- | Debug用途
instance Show SqlValue

-- | Representation of an SQL type.
-- 通常 TText, TInt, TDateTime のような形式
-- TRowID は SQL backend の型ではなく, selda の都合上導入されていた論理型なので不要
-- TNull は含めるべなのか？
-- いや, あくまで型であり Haskell の Bottom の存在な NULL は型ではない(はず)。
-- 含めないなら SqlParam -> SqlTypeRep は定義できない(Null のリテラルが何型の NULL か情報が落ちているため)
-- TODO: そもそもこの利用用途って何だ？？
data SqlTypeRep

instance Show SqlTypeRep
instance Eq SqlTypeRep
instance Ord SqlTypeRep

-- TODO: 改修が済むまで TRowID を提供
rowIDSqlType :: SqlTypeRep

-- | Any datatype representable in SQL.
-- 実際にサポートされている型のみ。
-- NULL や 抽象化された ID は SqlType 型クラス('なし)で考慮する。
-- というかここでは instance 定義はできあにので,全ての backend で Maybe a や ID a の instance 実装が必要になる。
-- あと SqlType, SqlType' を分けないと orphan instance の問題が。
-- まあ関連ライブラリのみに閉じているからいいかもだけど...
--
-- TDOO: SqlType, SqlType' を分けているのが吉と出るか...
-- TODO: Typeable 制約は SqlType のために付けているだけで後から外せるかも
class Typeable a => SqlType' a where
    -- | Create a literal of this type.
    toSqlParam :: a -> SqlParam
    -- | The SQL representation for this type.
    sqlTypeRep :: SqlTypeRep
    -- | Convert an SqlValue into this type.
    fromSqlValue :: SqlValue -> a
    -- | Pring for insperct purpose
    inspectPrint :: a -> Text
    -- | Default value when using 'def' at this type.
    -- TODO: DEPRECATE。DEFAULTカラムの insert 時に使っているがこれは本来ライブラリが決めるべき値ではない。
    -- 例えば Bool の DefaultValue って分からんぞ,という感じ
    defaultValue :: a

{-
微妙なところ。
例えば SQLite はカラム定義として Bool はないが, Int の 1/0 が true/false として扱われている。
selda は SQL構築する際に Col s Bool を使っており, SqlType Bool がないと Database.Selda モジュールのコンパイルが通らない。
厳密に言うと カラムが取れる型と SQL中の型は一致しない。
ただ厳密にやりすぎると ergnomics が下がるため取りあえず以下のものはどのバックエンドも最低限の要求とする。
-}
instance SqlType' Int
instance SqlType' Text
instance SqlType' Double
instance SqlType' Bool

-- | Any column type that can be used with the 'min_' and 'max_' functions.
-- | Int
class SqlType' a => SqlOrdable a
